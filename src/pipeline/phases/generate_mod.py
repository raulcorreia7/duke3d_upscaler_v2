"""
Generate Mod Phase - Generate final mod packages
"""
import os
import logging
import subprocess
import shutil
from typing import Dict, Any
from .base import AbstractPhase


class GenerateModPhase(AbstractPhase):
    """Generate final mod packages"""

    def __init__(self, config: Dict[str, Any], state):
        super().__init__(config, state)
        self.logger = logging.getLogger(self.__class__.__name__)

    def run(self):
        """
        Execute the generate mod phase
        """
        self.logger.info("Starting generate mod phase")
        
        # Check for required files
        if not self._check_required_files():
            self.logger.error("Missing required files in files/output/30_upscale")
            raise FileNotFoundError("Missing required files in files/output/30_upscale")
        
        # Create output directory
        output_dir = os.path.join("outputs")
        os.makedirs(output_dir, exist_ok=True)
        
        # Optimize PNGs
        self._optimize_pngs()
        
        # Generate DEFS.CON
        self._generate_defs_con()
        
        # Generate upscale.CON
        self._generate_upscale_con()
        
        # Package the mod
        self._package_mod()
        
        # Update the state
        self._update_state("generate_mod", "completed")
        self.logger.info("Generate mod phase completed")

    def _check_required_files(self):
        """
        Check for required files in the files/output/32_scrub/textures directory
        """
        scrub_dir = os.path.join("files", "output", "32_scrub", "textures")
        if not os.path.exists(scrub_dir):
            return False
        
        # Check for files in the directory
        if not os.listdir(scrub_dir):
            return False
        
        # If we have files, we should be good
        return True

    def _optimize_pngs(self):
        """
        Optimize PNGs with pngcrush -reduce
        """
        # Check if pngcrush is available
        if not shutil.which("pngcrush"):
            self.logger.warning("pngcrush is not installed or not in the PATH, skipping PNG optimization")
            return
        
        # Get input and output directories
        input_dir = os.path.join("files", "output", "32_scrub", "textures")
        output_dir = os.path.join("files", "temp", "32_scrub_optimized")
        os.makedirs(output_dir, exist_ok=True)
        
        # Process all PNG files
        for filename in os.listdir(input_dir):
            if filename.endswith(".png"):
                input_path = os.path.join(input_dir, filename)
                output_path = os.path.join(output_dir, filename)
                
                self.logger.info("Optimizing %s", filename)
                try:
                    # Run pngcrush with -reduce
                    result = subprocess.run(
                        ["pngcrush", "-reduce", input_path, output_path],
                        check=True,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        text=True
                    )
                    self.logger.info("Successfully optimized %s", filename)
                except subprocess.CalledProcessError as e:
                    self.logger.error("Error optimizing %s: %s", filename, e.stderr)
                    # Copy the original file if optimization fails
                    shutil.copy(input_path, output_path)
        
        # Replace the original files with optimized ones
        for filename in os.listdir(output_dir):
            if filename.endswith(".png"):
                src = os.path.join(output_dir, filename)
                dst = os.path.join(input_dir, filename)
                shutil.copy(src, dst)
        
        # Clean up
        shutil.rmtree(output_dir)

    def _generate_defs_con(self):
        """
        Generate DEFS.CON with indexed hightiles
        """
        # Create the output directory
        output_dir = os.path.join("files", "output", "duke3d")
        os.makedirs(output_dir, exist_ok=True)
        
        # Create the DEFS.CON file
        defs_path = os.path.join(output_dir, "DEFS.CON")
        with open(defs_path, "w") as f:
            f.write("// DEFS.CON - Definitions for hightiles\n")
            f.write("// Auto-generated by Duke3D Upscale Pipeline\n\n")
            
            # Add hightile definitions
            scrub_dir = os.path.join("files", "output", "32_scrub", "textures")
            if os.path.exists(scrub_dir):
                for filename in os.listdir(scrub_dir):
                    if filename.endswith(".png"):
                        # Extract the tile number from filename
                        # Assuming filenames like "TILE0001.png"
                        tile_name = os.path.splitext(filename)[0]
                        if tile_name.startswith("TILE"):
                            tile_number = tile_name[4:]  # Remove "TILE" prefix
                            f.write(f"hightile {tile_number} {filename}\n")
        
        self.logger.info("Generated DEFS.CON")

    def _generate_upscale_con(self):
        """
        Generate upscale.CON with engine settings
        """
        # Create the output directory
        output_dir = os.path.join("files", "output", "duke3d")
        os.makedirs(output_dir, exist_ok=True)
        
        # Create the upscale.CON file
        upscale_path = os.path.join(output_dir, "upscale.CON")
        with open(upscale_path, "w") as f:
            f.write("// upscale.CON - Engine settings for upscaled assets\n")
            f.write("// Auto-generated by Duke3D Upscale Pipeline\n\n")
            
            # Add engine settings
            f.write("gamevar UPSCALE_ENABLED 1\n")
            f.write("gamevar UPSCALE_FACTOR 4\n")
            f.write("gamevar UPSCALE_QUALITY 100\n\n")
            
            # Add texture filtering settings
            f.write("gl_texture_filter 5\n")
            f.write("gl_texture_filter_anisotropic 16\n")
            f.write("gl_texture_compression 0\n")
        
        self.logger.info("Generated upscale.CON")

    def _package_mod(self):
        """
        Package the mod files into the output directory
        """
        # Create output directory
        output_dir = os.path.join("files", "output", "duke3d")
        os.makedirs(output_dir, exist_ok=True)
        
        # Copy final textures
        scrub_dir = os.path.join("files", "output", "32_scrub", "textures")
        if os.path.exists(scrub_dir):
            for filename in os.listdir(scrub_dir):
                if filename.endswith(".png"):
                    src = os.path.join(scrub_dir, filename)
                    dst = os.path.join(output_dir, filename)
                    shutil.copy(src, dst)
        
        # Copy audio files
        audio_dir = os.path.join("files", "output", "20_convert", "audio")
        if os.path.exists(audio_dir):
            for filename in os.listdir(audio_dir):
                if filename.endswith(".wav"):
                    src = os.path.join(audio_dir, filename)
                    dst = os.path.join(output_dir, filename)
                    os.makedirs(os.path.dirname(dst), exist_ok=True)
                    shutil.copy(src, dst)
        
        # Copy animation frames
        frames_dir = os.path.join("files", "output", "20_convert", "frames")
        if os.path.exists(frames_dir):
            for dirname in os.listdir(frames_dir):
                src = os.path.join(frames_dir, dirname)
                dst = os.path.join(output_dir, "frames", dirname)
                if os.path.isdir(src):
                    shutil.copytree(src, dst, dirs_exist_ok=True)
        
        self.logger.info("Packaged mod files to %s", output_dir)